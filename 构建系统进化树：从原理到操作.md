<a name="content">目录</a>

[构建系统进化树：从原理到操作](#title)
- [系统发育分析的一般步骤](#steps)
- [原理](#principle)
	- [多序列比对](#multi-align)
	- [建树方法](#construct-phylogenetic-tree)
		- [两种分子数据](#2-type-characters)
		- [基于距离的建树方法](#distance-based-methods)
			- [UPGMA 算法](#upgma)
			- [Fitch-Margoliash 算法](#fitch-margoliash)
		- [基于特征的建树方法](#character-based-methods)
			- [最大简约法](#max-parsimony)
			- [最大似然法](#max-likelihood)
		- [选择不同建树方法的原则](#how-to-chose-proper-method)




<h1 name="title">构建系统进化树：从原理到操作</h1>

<a name="steps"><h2>系统发育分析的一般步骤 [<sup>目录</sup>](#content)</h2></a>

<p align="center"><img src=./picture/Phylogenesis-steps.png width=600 /></p>

<a name="principle"><h2>原理 [<sup>目录</sup>](#content)</h2></a>

<a name="multi-align"><h3>多序列比对 [<sup>目录</sup>](#content)</h3></a>



<a name="construct-phylogenetic-tree"><h3>建树方法 [<sup>目录</sup>](#content)</h3></a>


<a name="2-type-characters"><h4>两种分子数据 [<sup>目录</sup>](#content)</h4></a>

- **距离数据**(distance data)：常用距离矩阵描述，表示两个数据集之间所有的两两差异

<p align="center"><img src=./picture/Phylogenesis-define-of-distance.png width=600 /></p>

计算距离矩阵的例子：

<p align="center"><img src=./picture/Phylogenesis-compute-distance-example.png width=600 /></p>

- **特征数据**(character data)：表示分子所具有的特征

<p align="center"><img src=./picture/Phylogenesis-define-of-character.png width=600 /></p>

<a name="distance-based-methods"><h4>基于距离的建树方法 [<sup>目录</sup>](#content)</h4></a>

<p align="center"><img src=./picture/Phylogenesis-distance-based-methods-abstract.png width=600 /></p>

由距离法得到的进化树称为**距离树**

<a name="upgma"><h4>UPGMA [<sup>目录</sup>](#content)</h4></a>

UPGMA (unweighted pair-group method using an arithmetic average)：非加权成组配对法，又称为平均连接法

特点：**假设每个OTU的进化速率相同**，即每个OTU到树根的距离都相同

UPGMA算法的执行过程：

<p align="center"><img src=./picture/Phylogenesis-UPGMA-steps-1.png width=600 /></p>

<p align="center"><img src=./picture/Phylogenesis-UPGMA-example-1.png width=400 /></p>

<p align="center"><img src=./picture/Phylogenesis-UPGMA-steps-2.png width=600 /></p>

<p align="center"><img src=./picture/Phylogenesis-UPGMA-example-2.png width=500 /></p>

不断循环，直到只剩下一个类为止

<a name="fitch-margoliash"><h4>Fitch-Margoliash 算法 [<sup>目录</sup>](#content)</h4></a>

FM法允许OTU之间存在不同的进化速率

FM算法的执行过程：

<p align="center"><img src=./picture/Phylogenesis-FM-steps.png width=600 /></p>

<p align="center"><img src=./picture/Phylogenesis-FM-example.png width=400 /></p>

其本质是**求解三元一次方程组**

Q：为什么将剩余序列看成一个简单符合序列可以算出A和B间的距离？

<p align="center"><img src=./picture/Phylogenesis-FM-testify.jpg width=400 /></p>


<a name="character-based-methods"><h4>基于特征的建树方法 [<sup>目录</sup>](#content)</h4></a>

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-abstract.png width=600 /></p>

有最大简约法和最大似然法得到的进化树分别称为
> - 最大简约树
> - 最大似然树

问题：
> - 给定n个物种
> - m个用于描述物种的特征
> - 每个物种所对应的特征值

目标：构建一棵系统发育树，使得某个目标函数最大

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-character-input.png width=600 /></p>

<a name="max-parsimony"><h4>最大简约法 [<sup>目录</sup>](#content)</h4></a>

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-MP-objective.png width=600 /></p>

最大简约法只考虑**信息位点**，即只从信息位点进行进化树的构建

> **信息位点** (Informative site) ：至少存在2个不同的 碱基且每个不同碱基至少出现两次的位点

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-MP-informative-site.png width=400 /></p>

示例：

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-MP-example.png width=800 /></p>

> - position 5,7,9 为信息位点
> - 基于position 5的三个MP树：Tree1的长度为1，Tree2的长度为2，Tree3的长度为3
> - 再计算基于position 7,9的MP树的长度，得到MP树的总长：Tree1总长4，Tree2总长5，Tree3总长6
> - Tree1最为简约

<a name="how-to-chose-proper-method"><h4>选择不同建树方法的原则 [<sup>目录</sup>](#content)</h4></a>

<p align="center"><img src=./picture/Phylogenesis-how-to-chose-proper-method.png width=600 /></p>




