<a name="content">目录</a>

[构建系统进化树：从原理到操作](#title)
- [系统发育分析的一般步骤](#steps)
- [原理](#principle)
	- [多序列比对](#multi-align)
	- [建树方法](#construct-phylogenetic-tree)
		- [两种分子数据](#2-type-characters)
		- [基于距离的建树方法](#distance-based-methods)
			- [UPGMA 算法](#upgma)
			- [Fitch-Margoliash 算法](#fitch-margoliash)
		- [基于特征的建树方法](#character-based-methods)
			- [最大简约法](#max-parsimony)
			- [最大似然法](#max-likelihood)
		- [选择不同建树方法的原则](#how-to-chose-proper-method)
	- [进化树评估](#evaluate)
		- [Bootstrap](#bootstrap)
- [操作](#operation)
	- [MEGA7-GUI](#mega7-gui)
		- [Aligning Sequences](#align)


<h1 name="title">构建系统进化树：从原理到操作</h1>

<a name="steps"><h2>系统发育分析的一般步骤 [<sup>目录</sup>](#content)</h2></a>

<p align="center"><img src=./picture/Phylogenesis-steps.png width=600 /></p>

<a name="principle"><h2>原理 [<sup>目录</sup>](#content)</h2></a>

<a name="multi-align"><h3>多序列比对 [<sup>目录</sup>](#content)</h3></a>



<a name="construct-phylogenetic-tree"><h3>建树方法 [<sup>目录</sup>](#content)</h3></a>


<a name="2-type-characters"><h4>两种分子数据 [<sup>目录</sup>](#content)</h4></a>

- **距离数据**(distance data)：常用距离矩阵描述，表示两个数据集之间所有的两两差异

<p align="center"><img src=./picture/Phylogenesis-define-of-distance.png width=600 /></p>

计算距离矩阵的例子：

<p align="center"><img src=./picture/Phylogenesis-compute-distance-example.png width=600 /></p>

- **特征数据**(character data)：表示分子所具有的特征

<p align="center"><img src=./picture/Phylogenesis-define-of-character.png width=600 /></p>

<a name="distance-based-methods"><h4>基于距离的建树方法 [<sup>目录</sup>](#content)</h4></a>

<p align="center"><img src=./picture/Phylogenesis-distance-based-methods-abstract.png width=600 /></p>

由距离法得到的进化树称为**距离树**

<a name="upgma"><h4>UPGMA [<sup>目录</sup>](#content)</h4></a>

UPGMA (unweighted pair-group method using an arithmetic average)：非加权成组配对法，又称为平均连接法

特点：**假设每个OTU的进化速率相同**，即每个OTU到树根的距离都相同

UPGMA算法的执行过程：

<p align="center"><img src=./picture/Phylogenesis-UPGMA-steps-1.png width=600 /></p>

<p align="center"><img src=./picture/Phylogenesis-UPGMA-example-1.png width=400 /></p>

<p align="center"><img src=./picture/Phylogenesis-UPGMA-steps-2.png width=600 /></p>

<p align="center"><img src=./picture/Phylogenesis-UPGMA-example-2.png width=500 /></p>

不断循环，直到只剩下一个类为止

<a name="fitch-margoliash"><h4>Fitch-Margoliash 算法 [<sup>目录</sup>](#content)</h4></a>

FM法允许OTU之间存在不同的进化速率

FM算法的执行过程：

<p align="center"><img src=./picture/Phylogenesis-FM-steps.png width=600 /></p>

<p align="center"><img src=./picture/Phylogenesis-FM-example.png width=400 /></p>

其本质是**求解三元一次方程组**

Q：为什么将剩余序列看成一个简单符合序列可以算出A和B间的距离？

<p align="center"><img src=./picture/Phylogenesis-FM-testify.jpg width=400 /></p>


<a name="character-based-methods"><h4>基于特征的建树方法 [<sup>目录</sup>](#content)</h4></a>

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-abstract.png width=600 /></p>

有最大简约法和最大似然法得到的进化树分别称为
> - 最大简约树
> - 最大似然树

问题：
> - 给定n个物种
> - m个用于描述物种的特征
> - 每个物种所对应的特征值

目标：构建一棵系统发育树，使得某个目标函数最大

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-character-input.png width=600 /></p>

<a name="max-parsimony"><h4>最大简约法 [<sup>目录</sup>](#content)</h4></a>

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-MP-objective.png width=600 /></p>

最大简约法只考虑**信息位点**，即只从信息位点进行进化树的构建

> **信息位点** (Informative site) ：至少存在2个不同的 碱基且每个不同碱基至少出现两次的位点

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-MP-informative-site.png width=400 /></p>

示例：

<p align="center"><img src=./picture/Phylogenesis-character-based-methods-MP-example.png width=800 /></p>

> - position 5,7,9 为信息位点
> - 基于position 5的三个MP树：Tree1的长度为1，Tree2的长度为2，Tree3的长度为3
> - 再计算基于position 7,9的MP树的长度，得到MP树的总长：Tree1总长4，Tree2总长5，Tree3总长6
> - Tree1最为简约

<a name="how-to-chose-proper-method"><h4>选择不同建树方法的原则 [<sup>目录</sup>](#content)</h4></a>

<p align="center"><img src=./picture/Phylogenesis-how-to-chose-proper-method.png width=600 /></p>

<a name="evaluate"><h4>进化树评估 [<sup>目录</sup>](#content)</h4></a>

问题：
> - 整棵树和它的组成部分（分支）的置信度是多少？
> - 这样得到正确的树的可能性比随机选出一棵是正确 的树的可能性大多少？

<a name="bootstrap"><h4>Bootstrap [<sup>目录</sup>](#content)</h4></a>

-  从排列的多序列中随机有放回的抽取某一列，构成相同长度的新的排列序列
-  重复上面的过程，得到多组新的序列
-  对这些新的序列进行建树，再观察这些树与原始树是否有差异，以此评价建树的可靠性

<p align="center"><img src=./picture/Phylogenesis-bootstrap.png width=600 /></p>




<a name="operation"><h2>操作 [<sup>目录</sup>](#content)</h2></a>

<a name="mega7-gui"><h3>MEGA7-GUI [<sup>目录</sup>](#content)</h3></a>

官方提供的示例文件位于`C:\Users\UserName\Documents\MEGA7\Examples\`文件夹下

<a name="align"><h4>Aligning Sequences [<sup>目录</sup>](#content)</h4></a>

1\. 新建一个序列比对任务

<p align="center"><img src=./picture/Phylogenesis-MEGA7-align-1.png width=800 /></p>

<p align="center"><img src=./picture/Phylogenesis-MEGA7-align-2.png width=300 /></p>

<p align="center"><img src=./picture/Phylogenesis-MEGA7-align-3.png width=300 /></p>

2\. 导入待比对的序列文件

<p align="center"><img src=./picture/Phylogenesis-MEGA7-align-4.png width=800 /></p>

选择`hsp20.fas`文件

3\. 多序列比对（MEGA提供两种多序列比对工具：ClustalW 和 MUSCLE）

先选中所有序列

<p align="center"><img src=./picture/Phylogenesis-MEGA7-align-5.png width=800 /></p>

用ClustalW（或 MUSCLE）进行多序列比对

<p align="center"><img src=./picture/Phylogenesis-MEGA7-align-6.png width=800 /></p>

使用ClustalW的默认参数，点击OK执行序列比对




参考资料：

(1) [百度文库：分子系统发育分析](https://wenku.baidu.com/view/d5c0798fa26925c52dc5bf77.html?from=search)

(2) [MEGA7 GUI 版本官方手册](https://www.megasoftware.net/web_help_7/hc_introduction_to_walk_through_mega.htm)

